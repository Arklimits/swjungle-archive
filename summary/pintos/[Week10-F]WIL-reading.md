# [Week 10] 정글 끝까지 TEAM 6


**********

### 1페이지 WEEK09 WIL

안녕하십니까? 6팀의 발표를 맡게 된 정재혁입니다.
저희 조는 Project 4 과제인 File System에 관해 발표를 준비했습니다.

***********

### 2페이지 목차

파일 시스템의 경우 FAT 부분과 파일/디렉토리로 나뉘어져 있습니다. 파일과 디렉토리 내용에 관해서는 이미 우리가 OS를 사용하면서 써왔기 때문에 친숙한 개념이라 생각하여 생략하고, FAT와 Inode 아키텍쳐에 관한 설명과 저희가 어떤 식으로 파일시스템을 구현했는지를 발표하겠습니다.

***********

### 3페이지 Free Map

기존의 Pintos는 freemap을 사용한 형태로 디스크를 사용하고 있습니다. freemap은 bitmap이라고 이해하시면 됩니다. 그래서 기존의 파일 시스템은 그림과 같이 단편화가 발생해 있으면 Data가 들어갈 수 없습니다.

따라서 우리는 disk를 효율적으로 사용하기 위해 bitmap에서 fat 방식으로 파일시스템을 수정하게 됩니다.

***********

### 4페이지 FAT

FAT란 File Allocate Table의 약자로 빈 Sector를 찾아 데이터를 기록한 뒤, 파일들의 연결된 정보를 FAT에 기록합니다. 각 FAT 클러스터는 다음 클러스터의 위치를 Value로 써 가지기 때문에 Linked List같은 형태를 띄게 됩니다. 그렇기에 FAT는 그림과 같이 끊어서 다음 파일의 정보를 저장할 수 있어 단편화를 최소화 할 수 있습니다.

***********

### 5페이지 Inode

 Inode란 파일이나 디렉토리에 대한 metadata를 가지고 있는 고유 식별자입니다. 파일과 디렉토리는 모두 inode를 갖고 있습니다. inode 구조체는 파일이나 디렉토리를 열 때 발생하는 inode_open() 함수를 실행하면 생성되며, 열리지 않았을 때는 inode_disk인 상태로 Disk에 저장되어 있습니다.

***********

### 6페이지 Inode 구조체

 Inode의 구조체는 다음과 같이 이뤄져있습니다. 파일시스템을 구현하면서 중요했던 부분은 disk sector와 open count 였습니다. 실제 disk의 어느 Sector에 있는지, 그리고 이 inode가 몇번 참조되었는 지를 확인해야 합니다. 소제목에는 없지만 Persistence Test, 즉 지속성 체크를 하게 되는데 OS를 한번 종료하고 다시 부팅한 후, 기존 disk sector에서 data를 읽어와 test를 한번 더 합니다. 이 것을 제대로 Check 하지 못했다면 persistence test가 Fail이 뜨게 됩니다.

 Inode Disk에는 비어있는 부분이 있어 파일 시스템을 수정할 때 자신이 필요하다고 생각하는 member를 임의로 추가하여 사용할 수 있는 부분이 있습니다. 대신에 섹터 용량인 512 byte를 맞춰주어야 합니다.

 이제 Subdirectory를 어떤식으로 구현했는지 설명하겠습니다.

***********

### 7페이지 Subdirectory 1

기존의 Pintos는 Root Directory 내에서 16개의 directory entry만을 갖고 파일만 할당하게 되어있습니다. 즉 directory는 root directory 단 하나만을 사용한다는 뜻입니다.

우리는 이를 여러개의 directory를 만들 수 있도록 수정할 수 있또록 구현해야 합니다. 이를 위해 mkdir이라는 디렉토리 생성 함수와 chdir이라는 현재 스레드가 작업중인 디렉토리의 위치를 변경하는 함수를 생성했습니다. 또한 현재 작업중인 디렉토리는 스레드에 종속되어야 하기 때문에 thread에 새로운 멤버를 추가해줬습니다.

***********

### 8페이지 Subdirectory 2

또한, 디렉토리의 위치가 절대적, 상대적일 수 있기 때문에 해당하는 내용을 parsing해주는 함수도 만들어 적용했습니다. 파일의 경로와 이름을 추출하여 경로로 들어가 name을 lookup하게 만들어 줍니다.

설명이 엄청 간단하고 우리가 친숙하게 알고있는 개념이라 금방 할 줄 알았는데 이 기능의 디버깅에만 30시간정도 태웠습니다..

************

### 9페이지 Soft Link

Soft Link에서는 리눅스의 Symbolic Link라는 것을 구현하라고 하는데 이는 Windows의 바로가기 같은 기능입니다. 이론은 딱히 설명을 안해도 될 것 같은 데, 특이한 점은 바로가기의 대상이 없는데 바로가기 파일을 먼저 만들고나서 나중에 대상을 만들어도 동작해야 합니다.

처음엔 link파일을 2중 포인터처럼 구현을 했었는데 이 기능을 구현하는게 너무 골치아파서 link에 그냥 원본 파일 name을 저장하여 lookup하도록 만들습니다. 이 기능 만드는 데도 20시간 정도 걸렸습니다. 은식님의 Tip이 없었다면 아마 더 걸렸을 것 같습니다.

************

### 10페이지 진행 상황

현재 Soft Link 까지 구현했고 Buffer Cache, 동기화, 지속성 테스트는 완료하지 못했습니다. 시간이 부족한게 안타까웠습니다. 현재 Test는 193개 중에 11개 남아 있는 상태입니다.

************

### 11페이지 느낀점

File System이 생각보다 많이 어려웠고 왜 이전에 Project 4를 오픈하지 않았는 지 몸으로 느껴볼 수 있는 경험이었다고 생각합니다.

디버깅만 50시간정도 했고 Project 1부터 커밋을 하드리셋 한 내용을 제외하더라도 400개 가까이 했는데 Pintos를 구현하면서 reset하거나 과거 시점으로 돌아가고 싶을 때가 많았습니다. 그때마다 원하는 시점에서 다시 디버깅할 수 있어서 좋은 습관을 들였다는 생각을 했습니다.

Pintos를 한달동안 엄청 오래했는데 생각보다 짧게 느껴졌던 것 같습니다. 모두들 한달동안 수고 많으셨습니다.

************

### 12페이지

감사합니다. 발표 마치겠습니다.
