# [Week 09] 정글 끝까지 TEAM 6


**********

### 1페이지 WEEK09 WIL

안녕하십니까? 6팀의 발표를 맡게 된 정재혁입니다.
저희 조는 Project 3의 Extra 과제인 Copy on Write에 관해 발표를 준비했습니다.

***********

### 2페이지 목차

자, 먼저 Copy on write를 아직 진행하지 못해보신 분들을 위해 간단하게 개념 정리부터 시작하겠습니다. 그리고 저희가 어떤 방식으로 구현했는지에 관한 코드와 발생한 문제점과 해결 방법까지 발표하겠습니다.

***********

### 3페이지 개념 정리 1

Git book에서는 copy on write에 대해 다음과 같이 정의하고 있습니다.

Copy-on-write은 동일한 물리 페이지의 인스턴스를 이용하여 더 빠른 복제 작업을 가능하게 하는 리소스 관리 기술입니다. 일반적으로, 어떤 리소스가 여러 프로세스에 의해 사용되는 경우, 충돌이 발생하지 않도록 각 프로세스에는 해당 리소스의 고유한 복사본이 있어야 합니다. 하지만 리소스가 수정되지 않고 읽기만 하는 경우에는 물리 메모리에 해당 리소스에 대한 여러개의 복사본이 있을 필요가 없습니다.

***********

### 4페이지 개념 정리 2

그래서 `fork`를 할 때에는 새로운 물리 페이지를 할당하지 않고 부모와 같은 물리 페이지를 매핑해주었다가 추후에 `write`를 시도할 때에만 새로운 물리 페이지를 할당해 주면 된다는 것입니다.

우리는 `Filebacked Page`의 경우에 이미 같은 물리 메모리를 공유하도록 구현했기 때문에 여기서 힌트를 얻을 수 있었습니다.

***********

### 5페이지 구조체에 멤버 추가

기존에 우리 프로그램은 이 페이지가 작성가능한지만을 검사하고 있었습니다. 그런데 이 페이지가 원래 부모 프로세스가 만들어 놓은 Anonymous Page이고  `fork`된 프로세스에서 `write` 하려고 한다면 이것을 막을 방법이 필요하다고 생각했습니다. 따라서 `fork`할 때 만드는 모든 Anon_page에 대해 `writable`을 `false`로 복사하여 `page fault`를 발생시킬 수 있을 것 같다는 아이디어가 떠올랐습니다. 

그런데, 이 것이 부모와 같은 `page`에 `write`하려고 하는 것인지 아니면 진짜로 작성하면 안되는 페이지를 요청한 것인지 구분할 필요가 있었습니다. 따라서 새로운 `accessible` 이라는 토큰을 추가했습니다.

************

### 6페이지 table_copy 수정

기존에 `ANON` 페이지를 `fork`할 때 새로운 페이지를 만들고 kva 또한 할당하여 (`claim_page` & `do_claim_page`) 물리 메모리를 그대로 복제하는 방식으로 구현했습니다. 

************

### 7페이지 copy_claim_page

이를 맵핑만 해놓고 kva는 생성하지 않고 기존의 kva를 받아오는 (copy_claim_page)라는 함수를 새로 만들었습니다. 이 때 frame을 새로 만드는 것까지는 동일하지만, 기존의 kva를 가리키게 만들고 accessible을 설정해 준 후 pml4를 writable을 무조건 0으로 만들어 주고나서 swap_in을 수행합니다.

이제 `fork`된 페이지에 대해서 `writable`가 무조건 0이기 때문에 해당 페이지에 `write`를 시도하면 `page_fault`가 발생합니다.

************

### 8페이지 handle_fault

이에 따라서 `try_handle_fault` 에서 이를 구분할 수 있어야 합니다. 그 동안은 `writable`이 금지된 페이지에 `write`를 시도했을 때 무조건 `false`를 반환했었는데 이를 `accessible token`을 검사하는 함수를 호출하도록 수정했습니다.

************

### 9페이지 handle_wp

먼저 페이지에 대해서 검사하는데 `access`가 금지되어 있다면 `fork`된 페이지가 아니라 실제로 접근해서는 안되는 페이지이기 때문에 바로 `false`를 리턴 해줍니다. 만약 `access` 가능하다면 이는 fork된 페이지기 떄문에 먼저 기존 kva을 백업해주고 kva에 `user_pool`에서 새로운 페이지를 할당합니다. 이 때 용량이 꽉 차서 할당할 수 없다면 evict_frame을 수행하여 만들어줍니다. 그 후 원본 kva를 현재 frame에 복원하고 pml4에 할당해 줍니다.

************

### 10페이지 문제점

이로써 우리는 자식 페이지에서 `write`를 할 때만 `kva`를 할당하는 `copy on write`를 구현할 수 있었습니다.

그러나 다른 곳에서 문제가 발생했습니다. 

자식 프로세스가 할 일 모두 끝내고 종료할 때 `Process_cleanup`을 수행하게 되는데 이 때 spt를 지우는 것 뿐만 아니라 pml4도 같이 파괴시킵니다. 그런데 우리의 프로세스가 부모의 `ANON_PAGE`를 가져와서 `write`를 시도하지 않은 페이지들은 아직 부모의 `kva`를 참조하고 있다면, 그래서 자식이 `exit` 할 때 해당 kva까지 파괴해버립니다. 그래서 추후에 부모가 접근하면 `fault`가 뜨는 문제가 발생했습니다.

따라서 이를 막아주기 위해 몇 가지 시도를 했습니다. 우리가 생각할 수 있었던 방법은 3가지 였습니다.

************

### 11페이지 해결방법 1

첫번째 방법으로 페이지를 `destroy`할 때 부모로 부터 `fork`된 페이지라면 삭제를 막고 `clear`만 하도록 수정하는 것이었습니다.

해당 방법을 시도했으나 페이지가 깔끔하게 삭제되지않고 잔여물이 남아서 `kernel offset`이 뒤틀리는 현상이 발생해 실패했습니다.


************

### 12페이지 해결방법 2

두번째는 fork 할 때 마다 각 페이지를 `marking`하여 남겨놨다가 나중에 `destroy`할 경우 `marking`된 페이지가 남아있다면 부모가 `exit`할 때 까지 그 페이지의 `destroy`를 막는 방법이었습니다.

해당 방법은 너무 복잡하고 수정해야 하는 범위가 너무 광범위하여 포기하게 되었습니다.

************

### 13페이지 해결방법 3

세번째는 그냥 `pml4_destroy`를 막고 `pml4_clear`만 수행하여 kva의 연결만 끊은 상태로 만들어 재가용하게 돌려주고 OS가 종료될 때만 memory를 destory 시키도록 하는 것이었습니다.

해당 방법으로 모든 메모리 누수를 잡아낼 수 있었고 프로젝트를 완료했습니다.

************

### 14페이지 감사합니다

감사합니다. 발표 마치겠습니다.
